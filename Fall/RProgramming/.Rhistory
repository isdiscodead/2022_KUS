my_out
my_out
my_out <- ggplot_build(bp)$data[[1]]$outliers[[1]]
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(var="Movie.Title")
top_movies <- alltime %>%
+ filter(alltime, Gross %in% my_out)
my_out <- ggplot_build(bp)$data[[1]]$outliers[[1]]
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(var="Movie.Title")
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(var="Movie.Title")
top_movies <- alltime %>%
+ filter(Gross %in% my_out)
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(var="Movie.Title")
str(alltime.movies)
alltime.movies
str(alltime.movies)
top_movies <- alltime %>%
+ filter(Gross %in% my_out)
alltime <- as_tibble(row.names(alltime.movies)) %>%
+ rownames_to_column(var="Movie.Title")
alltime <- as_tibble(alltime.movies)
alltime
alltime <- rownames_to_column(var="Movie.Title")
alltime <- rownames_to_column(alltime, var="Movie.Title")
top_movies <- alltime %>%
+ filter(Gross %in% my_out)
my_out <- ggplot_build(bp)$data[[1]]$outliers[[1]]
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(alltime, var="Movie.Title")
top_movies <- alltime %>%
+ filter(Gross %in% my_out)
library(UsingR)
bp <- ggplot(data=alltime.movies, mapping = aes(x='', y=Gross)) +
geom_boxplot() +
labs(x='')
library(UsingR)
bp <- ggplot(data=alltime.movies, mapping = aes(x='', y=Gross)) +
geom_boxplot() +
labs(x='')
bp + coord_flip()
my_out <- ggplot_build(bp)$data[[1]]$outliers[[1]]
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(alltime, var="Movie.Title")
top_movies <- alltime %>%
+ filter(Gross %in% my_out)
top_movies <- alltime %>%
+ filter(alltime.movies, Gross %in% my_out)
alltime
my_out <- ggplot_build(bp)$data[[1]]$outliers[[1]]
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(alltime, var="Movie.Title")
alltime
alltime <- as_tibble(alltime.movies, rownames = "") %>%
+ rownames_to_column(alltime, var="Movie.Title")
alltime <- as_tibble(alltime.movies, rownames = "movie") %>%
+ rownames_to_column(alltime, var="Movie.Title")
alltime <- as_tibble(alltime.movies, rownames = "Movie.Title") %>%
+ rownames_to_column(alltime, var="Movie.Title")
alltime <- as_tibble(alltime.movies, rownames = "Movie.Title") %>%
+ rownames_to_column(alltime)
alltime <- as_tibble(alltime.movies, rownames = "Movie.Title") %>%
+ rownames_to_column(alltime, var="Movie.Title")
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(alltime, var="Movie.Title")
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(alltime, var="Movie.Title")
alltime
# ggplot 맛보기
library(tidyverse)
ggplot(data=mpg) +
geom_point(mapping=aes (x=hwy, y=displ))
ggplot(data=mpg) +
geom_bar(mapping=aes (x=displ)) # geom_으로 시작하는 다양한 패키지
##################################
# 그룹별 그래프 작성 : Facet
# facet_wrap() : 범주형 변수가 하나일 때
ggplot(data=mpg) +
geom_point(mapping=aes(x=displ, y=hwy)) +
facet_wrap( ~class )
# pipe
head(iris)
iris%>%head() # tidyverse가 구동된 이후에 사용 가능
# pipe 사용 필터링 - facet wrap
mpg %>%
filter(class != "2seater") %>% ggplot() +
geom_point(mapping = aes(x=displ, y=hwy)) +
facet_wrap(~ class)
# pipe 사용 필터링 - facet grid
mpg %>%
filter(class != "2seater") %>% ggplot() +
geom_point(mapping = aes(x=displ, y=hwy)) +
facet_grid(~ class) # 일렬로 나온다
##################################
# 범주형 자료
# input data가 요인인 경우
str(state.region)
ggplot(data.frame(state.region)) +
geom_bar(aes(x=state.region)) +
labs(x="Region") +
coord_flip() # 막대 방향 바뀜
# input data가 도수 분포표인 경우
counts <- table(state.region)
df1 <- as.data.frame(counts)
ggplot(df1, aes(x=state.region, y=Freq)) +
geom_col(fill="steelblue") +
labs(x="Region", y="")
##################################
# 연속형 자료
# 상자 그림 ( boxplot ) 실습
library(UsingR)
bp <- ggplot(data=alltime.movies, mapping = aes(x='', y=Gross)) +
geom_boxplot() +
labs(x='')
bp + coord_flip()
# ggplot_build
my_out <- ggplot_build(bp)$data[[1]]$outliers
my_out <- my_out[[1]] # 처음엔 문제가 없지만 한 번 더 실행하면 601이 나와버림
my_out
my_out <- ggplot_build(bp)$data[[1]]$outliers[[1]]
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(alltime, var="Movie.Title")
alltime
top_movies <- alltime %>%
+ filter(Gross %in% my_out)
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(alltime, var="Movie.Title")
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(alltime, var="Movie.Title")
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(alltime, var="Movie.Title")
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(alltime.movies, var="Movie.Title")
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(alltime, var="Movie.Title")
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(var="Movie.Title")
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(.data, var="Movie.Title")
alltime <- as_tibble(alltime.movies) %>%
+ rownames_to_column(var="Movie.Title")
alltime <- as_tibble(alltime.movies) %>%
rownames_to_column(var="Movie.Title")
alltime
top_movies <- alltime %>%
+ filter(Gross %in% my_out)
alltime <- as_tibble(alltime.movies) %>%
rownames_to_column(alltime, var="Movie.Title")
alltime <- as_tibble(alltime.movies) %>%
rownames_to_column(var="Movie.Title")
alltime
top_movies <- alltime %>%
filter(Gross %in% my_out)
top_movies
alltime <- as_tibble(alltime.movies)[[1]] %>%
rownames_to_column(var="Movie.Title")
alltime <- as_tibble(alltime.movies)[1] %>%
rownames_to_column(var="Movie.Title")
alltime
top_movies <- alltime %>%
filter(Gross %in% my_out)
alltime
top_movies <- alltime %>%
filter(Gross %in% my_out)
top_movies
alltime <- as_tibble(alltime.movies)
alltime <- alltime.movies %>% rownames_to_column(var="Movie.Title") %>%
as_tibble(alltime.movies)
alltime <- alltime.movies %>% rownames_to_column(var="Movie.Title") %>%
as_tibble()
alltime
%>% as_tibble()
%>% as_tibble()
alltime <- alltime.movies %>% rownames_to_column(var="Movie.Title") %>% as_tibble()
alltime
top_movies <- alltime %>%
filter(Gross %in% my_out)
top_movies
women
ggplot(women, aes(x=height, y=weight)) + geom_point()
# 가정 1. 여성의 키가 클수록 몸무게가 높다
cor(women)
lm(y~x, women)
lm(weight~height, women)
# lm, sub, gsub 은 데이터가 먼저 나오지 X
fit <- lm(fomula = weight ~ height, women) # 기울기와 절편이 나온다
# lm, sub, gsub 은 데이터가 먼저 나오지 X
fit <- lm(weight ~ height, women) # 기울기와 절편이 나온다
fit
getwd()
setwd("./Documents/KUS/2022/Fall/RProgramming")
getwd()
a <- 10
print(a)
a <- 10 # 변수 할당 ... 자료형 신경 X
A <- 20 # 대소문자 구분함
print(a)
print(A)
help.start() # 메뉴얼을 보여주는 함수
?print() # 메서드나 모듈 등의 메뉴얼 확인 가능
# 어떤 레포지토리에 어떤 패키지가 있는지는 알 수 없음 ...
#
?CRAN.packages
setRepositories() # interactive 모드로 database 종류 선택 ... CRAN 디폴트
setRepositories() # interactive 모드로 database 종류 선택 ... CRAN 디폴트
install.packages("ggplot2") # ggplot2 패키지 설치
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
library(ggplot2)
variableOne = 1:10
print(variableOne
variableOne = 1:10
variableOne = 1:10
print(variableOne)
variableOne <- 1:10
print(variableOne)
print(variableOne[1])
variableTwo <- c("A", "B", "C")
print(variableTwo[2])
print(length(variableTwo))
length(variableTwo)
variableTwo[2]
variableThree <- c(1, 2, 3, "A", "B")
variableThree
install.packages("devtools")
library(devtools)
setRepositories(ind = 1:7)
install.packages("devtools")
library(devtools)
# Github에서 패키지 다운로드
install_github('jhk0530/Rstat') # devtool 있어야 사용 가능
install.packages("devtools")
library(devtools)
install_github('jhk0530/Rstat') # devtool 있어야 사용 가능
install.packages("ggVennDiagram")
install.packages("animation")
library(Rstat)
library(ggVennDiagram)
library(animation)
library(dplyr)
nsides <- 6
times <- 2
for (i in 1:times) {
temp[[i]] <- 1:nsides
}
temp <- list() # 빈 list 생성
for (i in 1:times) {
temp[[i]] <- 1:nsides
}
temp
S <- expand.grid(temp, KEEP.OUT.ATTRS = FALSE)
names(S) <- c(paste(rep("Dice_", times), 1:times, sep = ""))
nrow(S)
## Set two fair dice (Self-Checking 1)
nsides <- 6 # 6면체의 주사위
times <- 7 # 7개의 주사위
temp <- list() # 빈 list 생성
for (i in 1:times) { # 두 개의 주사위 ...
temp[[i]] <- 1:nsides
}
temp
## Sample Space S
S <- expand.grid(temp, KEEP.OUT.ATTRS = FALSE)
names(S) <- c(paste(rep("Dice_", times), 1:times, sep = ""))
nrow(S) # sample space의 원소 개수 6*6
## For combination
S
for(i in 1:nrow(S)){
S[i,] <- sort(as.numeric(S[i,]))
}
## Set two fair dice (Self-Checking 1)
nsides <- 6 # 6면체의 주사위
times <- 2 # 2개의 주사위
temp <- list() # 빈 list 생성
for (i in 1:times) { # 두 개의 주사위 ...
temp[[i]] <- 1:nsides
}
temp
## Sample Space S
S <- expand.grid(temp, KEEP.OUT.ATTRS = FALSE)
names(S) <- c(paste(rep("Dice_", times), 1:times, sep = ""))
nrow(S) # sample space의 원소 개수 6^2
## For combination
S
for(i in 1:nrow(S)){
S[i,] <- sort(as.numeric(S[i,]))
}
distinct(S) # no order ... (2,3) == (3, 2)
S <- distinct(S)
nrow(S)
## Get Event A -> sum of the dice values is even
eventA <- subset(S, ((Dice_1+Dice_2) %% 2)==0)
element(eventA)
## Get Event B -> sum >= 8
eventB <- subset(S, (Dice_1+Dice_2) >=8)
element(eventB)
## Get Event C -> a - b < 1
eventC <- subset(S, abs(Dice_1 - Dice_2) <= 1)
element(eventC)
## Get Event C -> a - b < 1
eventC <- subset(S, abs(Dice_1 - Dice_2) < 1)
element(eventC)
AB <- intersect2(eventA, eventB)
AB <- intersect2(eventA, eventB)
AB
AC <- intersect2(eventA, eventC)
AC
BC <- intersect2(eventB, eventC)
BC
Ac <- setdiff(S, eventA)
Ac <- setdiff(S, eventA)
Ac
Bc <- setdiff(S, eventB)
Bc
Cc <- setdiff(S, eventC)
Cc
element(Ac)
vennData <- list(A = element(eventA),
B = element(eventB),
C = element(eventC))
ggVennDiagram(vennData)
## Simulation of law of large numbers (Self-Checking 2) 대수의 법칙
# relative frequency를 무한대로 늘리면 계산된 probability에 수렴
ani.options(nmax = 1000, interval = 0.00001) # animation 라이브러리로 ... 중요한 내용은 아님
win.graph(7,4)
## Complement ; 여집합 = 전체 - 집합
Ac <- setdiff(S, eventA) # 홀수 합
nTimes <- 100
eventCoin <- c()
for(i in 1:nTimes){
eventCoin[i] <- rbinom(1, size=1, prob = 0.5)
print(paste0(i, " times drawing... Prob(Head) = ", (sum(eventCoin == 1) / length(eventCoin))))
}
nTimes <- 1000
eventCoin <- c()
for(i in 1:nTimes){
eventCoin[i] <- rbinom(1, size=1, prob = 0.5)
print(paste0(i, " times drawing... Prob(Head) = ", (sum(eventCoin == 1) / length(eventCoin))))
}
nTimes <- 5000 # 100일때 0.39, 1000일때 0.494, 5000일 때
eventCoin <- c()
for(i in 1:nTimes){
eventCoin[i] <- rbinom(1, size=1, prob = 0.5)
print(paste0(i, " times drawing... Prob(Head) = ", (sum(eventCoin == 1) / length(eventCoin))))
}
## Self-Checking non-amination version
nTimes <- 1000 # 100일때 0.39, 1000일때 0.494, 5000일 때 0.5094
eventCoin <- c()
for(i in 1:nTimes){
eventCoin[i] <- rbinom(7, size=1, prob = 100/6) # 확률 0.5로 0또는 1 생성
print(paste0(i, " times drawing... Prob(Head) = ", (sum(eventCoin == 1) / length(eventCoin))))
}
for(i in 1:nTimes){
eventCoin[i] <- rmultinom(1, size=6, prob = 100/6) # 확률 100/6 확률로 0~6 생성
print(paste0(i, " times drawing... Prob(Head) = ", (sum(eventCoin == 1) / length(eventCoin))))
}
nTimes <- 1000 # 100일때 0.39, 1000일때 0.494, 5000일 때 0.5094
eventCoin <- c()
for(i in 1:nTimes){
eventCoin[i] <- rmultinom(1, size=6, prob = 100/6) # 확률 100/6 확률로 0~6 생성
print(paste0(i, " times drawing... Prob(Head) = ", (sum(eventCoin == 1) / length(eventCoin))))
}
## Self-Checking non-amination version
nTimes <- 5000 # 100일때 0.39, 1000일때 0.494, 5000일 때 0.5094
rmultinom(1, size=6, prob = 100/6)
for(i in 1:nTimes){
eventCoin[i] <- rmultinom(1, size=6, prob = 100/6) # 확률 100/6 확률로 0~6 생성
print(paste0(i, " times drawing... Prob(Head) = ", (sum(eventCoin == 1) / length(eventCoin))))
}
rmultinom(1, size=6, prob = 100/6)
rmultinom(1, size=6, prob = 100/6)
rmultinom(1, size=6, prob = 100/6)
rmultinom(1, size=6, prob = 100/6)
eventCoin <- c()
for(i in 1:nTimes){
rmultinom(1, size=6, prob = 100/6)
}
print(rmultinom(1, size=6, prob = 100/6))
for(i in 1:nTimes){
print(rmultinom(1, size=6, prob = 100/6))
}
eventCoin <- c()
for(i in 1:nTimes){
print(rmultinom(1, size=6, prob = 1/6))
}
for(i in 1:nTimes){
print(rbinom(1, size=6, prob = 1/6))
}
# 더 적절한 방법
nTimes <- 1000 # 100일때 0.39, 1000일때 0.494, 5000일 때 0.5094
eventDice <- c()
expectedOutcome <- 1:6
for ( i in 1:nTimes ) {
eventDice[i] <- sample(expectedOutcome)[1]
print(paste0(i, " times drawing... Prob(Head) = ", (sum(eventDice == 1) / length(eventDice))))
}
# 더 적절한 방법
nTimes <- 1000 # 100일때 0.39, 1000일때 0.494, 5000일 때 0.5094
eventDice <- c()
expectedOutcome <- 1:6
for ( i in 1:nTimes ) {
eventDice[i] <- sample(expectedOutcome)[1]
print(eventDice[i])
print(paste0(i, " times drawing... Prob(Head) = ", (sum(eventDice == 1) / length(eventDice))))
}
# 더 적절한 방법
nTimes <- 1000 # 100일때 0.39, 1000일때 0.494, 5000일 때 0.5094
eventDice <- c()
expectedOutcome <- 1:6
for ( i in 1:nTimes ) {
eventDice[i] <- sample(expectedOutcome)[1]
print(eventDice[i])
print(paste0(i, " times drawing... Prob(Head) = ", (sum(eventDice == 1) / length(eventDice))))
}
S <- tosscoin2(3) # sample space 생성
##################################
## Lecture Material             ##
## for Probability & Statistics ##
## Jiwon Lee                    ##
## 2022-09-28                   ##
##################################
setRepositories(ind = 1:7)
#install.packages("devtools")
#install_github('jhk0530/Rstat')
#install.packages("ggVennDiagram")
#install.packages("animation")
library(devtools)
library(Rstat)
library(ggVennDiagram)
library(animation)
library(dplyr)
library(scatterplot3d)
#####################################################################
## Set two fair dice (Self-Checking 1)
nsides <- 6
times <- 2
temp <- list()
for (i in 1:times) {
temp[[i]] <- 1:nsides
}
## Sample Space S
S <- expand.grid(temp, KEEP.OUT.ATTRS = FALSE)
names(S) <- c(paste(rep("Dice_", times), 1:times, sep = ""))
nrow(S)
## For combination
S
for(i in 1:nrow(S)){
S[i,] <- sort(as.numeric(S[i,]))
}
distinct(S)
S <- distinct(S)
nrow(S)
## Get Event A
eventA <- subset(S, ((Dice_1+Dice_2) %% 2)==0)
element(eventA)
## Get Event B
eventB <- subset(S, (Dice_1+Dice_2) >=8)
element(eventB)
## Get Event C
eventC <- subset(S, abs(Dice_1 - Dice_2) <= 1)
element(eventC)
## Intersection
AB <- intersect2(eventA, eventB)
element(AB)
AC <- intersect2(eventA, eventC)
element(AC)
BC <- intersect2(eventB, eventC)
element(BC)
## Complement
Ac <- setdiff(S, eventA)
element(Ac)
Bc <- setdiff(S, eventB)
element(Bc)
Cc <- setdiff(S, eventC)
element(Cc)
## Drawing Venn-diagram
vennData <- list(A = element(eventA),
B = element(eventB),
C = element(eventC))
ggVennDiagram(vennData)
####################################################################
## Simulation of law of large numbers (Self-Checking 2)
ani.options(nmax = 1000, interval = 0.00001)
win.graph(7,4)
## Self-Checking 1
S <- tosscoin2(3) # sample space 생성
X <- apply(S, 1, countT) # apply random variable -> real value
X <- apply(S, 1, countT) # apply random variable -> real value
## Self-Checking 1
S <- tosscoin2(3) # sample space 생성
countT <- function(x){ # random variable = function
sum(x == "T") # how many ...
}
X <- apply(S, 1, countT) # apply random variable -> real value
pX <- table(X) / nrow(S)
pX
plot(pX)
nTimes <- 4
S <- rolldie2(nTimes)
N <- nrow(S)
X <- apply(S, 1, sum) # random var
X.freq <- table(X)
print(addmargins(X.freq))
X.prob <- X.freq/N
print(round(addmargins(X.prob), 4))
X.val <- as.numeric(names(X.freq))
