# 01. 계산적 사고란 무엇인가

## I. 컴퓨터, 어디에나 있는 컴퓨터

### **computer** : 계산하는 사람 -> 기계식 -> 전자식 -> 양자식
- `전자식` -> 저항으로 조절해 전기 흐르면 1, 안 흐르면 0

### **Algorithm** : 컴퓨터를 이용해 풀 수 있는 문제의 해결 방법
-> 최초의 알고리즘( 논리적 흐름 )? 유클리드의 최대 공약수

프로그램 -> 장치에게 실행 방법을 명령, 프로그램마다 다른 결과 
응용 프로그램 / 시스템 SW ~/~ FirmWare( 기계어 ) ~/~ Hardware


<br>

## II. 최초의 소프트웨어 

    주판, 안티키테라 메커니즘 -> 파스칼린 -> 라이프니츠 계산기
1. `자카드 직기` -> 프로그램이 가능한 첫 번째 기계
2. `해석기관` -> 천공카드 방식의 기계식 계산기 이론 
    - 찰스 베비지 & 에이다 러브레이스 -> 최초의 컴퓨터 프로그래머

### 산업 혁명 
1. [1784] 증기 기관 + 기계화
2. [1870] 전기 + 대량 생산
~ 진공관 컴퓨터 
3. [1969] 컴퓨터 정보화 + 자동화
4. [2016] 인공지능

<br>

## III. 현대적 컴퓨터란? 
1. 전용 기계식 X -> 전자식( 전기로 동작 )
2. 아날로그 X -> 디지털( 비연속 )
3. 내장프로그램( SW ) 개념  
    - 입력 장치 / 출력 장치
    - 메모리 
    - 프로세서

<br>

## IV. 최초의 현대적 컴퓨터 
### `미분해석기` ( 전기 + 아날로그 회로 )
### **`ENIAC`** -> 디지털 + 전기 + 내장프로그램 ... 진공관 메모리
### `ABC 컴퓨터` -> 저장 / 범용 X, 최초의 완전 전자식
### `Z 시리즈` -> 최초의 범용 전자식, 내장 프로그램 X
### **`콜로서스`** -> 독일군 암호(이니그마) 해독, 경우의 수 자동화 
- `이미테이션 게임 ( turing test )` : 심판 vs 대상, 질문을 통해 인간인가, 기계인가 구분 불가능 -> 인공 지능
- `컴퓨터란?` 한가지가 아닌 여러 문제, 그냥 프로그램이 아닌 재프로그래밍 가능, 계산 뿐만 아니라 사람처럼 이후의 처리까지 생각하는 전자 두뇌 
- `기계가 생각을 할 수 있는가?` 사람처럼 할 순 X, 그러나 다르다고 생각하지 않는 것은 아님. 사람의 뇌가 다 다르듯이 기계도 서로 다르게 생각할 것. 

<br>

## V. 무어의 법칙
`Transister` -> 가변 저항 ( V=IR에서 저항을 조절해 0, 1 변경 )

`집적회로` -> 많은 양의 트랜지스터 단일 chip에 결합한 실리콘 웨어퍼
( 반도체 기술 ... bit, Tr, 선폭 속성 가짐 )

### Moore's Law 
인텔 창업자의 예견, 18개월 간격으로 집적회로 내 소자의 개수 *= 2 

-> 더 많은 소자들이 동일한 집적 회로 공간에? 전류가 흐르는 거리는 짧아지고 회로 속도는 상승 ! 

---
<br>

# 02. 실세계 정보는 어떻게 계산 가능한 데이터가 되는가?

## I. 정보와 데이터
|현실|컴퓨터세계|
|----|-----|
|정보( inform )|데이터( data )|
|연속적|이산적|
|아날로그 부호화|디지털 부호화|

*-> 이진수( bit)은 디지털 시스템의 최소 단위*

<br>

## II. 데이터 용량
- `byte` = 8bit, 256( 2^8 )개 패턴
- `word` : 하드웨어에 기반을 둔 데이터 용량 단위, CPU의 단일 항목 처리
    - bit수는 8의 배수로, 유형 별로 필요한 메모리 양이 다름 

<br> 

## III. 기수법
- `위치 기수법` : 밑( base ) / 기수 ( radix ) : 특정 기수법에 얼마나 많은 숫자가 존재하는지 명시하여 숫자 표현, 숫자의 위치는 밑의 거듭제곱과 연관됨
- `이진 기수법` : 밑을 2로 하는 위치 기수법, 각 숫자의 위치는 2의 멱승을 표시하고 값은 배수 ( 이진법 )

<br>

## IV. Bit 단위 숫자 표현
1. `sign-magnitude` 방식 int 표현
    - 맨 앞 비트를 부호 비트로 사용 (0 양수, 1 음수) -> -0과 +0이 생김
2. `2의 보수` 방식 int 표현
    - 1에 2의 보수 = -1 ( 부호 뒤집고 1 더하기 )

사용 비트 수의 한계, `정밀도` 제한 
-> `overflow`( 너무 큰 수 ) / `underflow`( 소수점 너무 작은 수 ) 오류 발생

<br>

## V. 다양한 데이터 표현
- 텍스트 -> `ASCII` 코드
- 색상 -> `RGB` ( 8bit * 3 chanel )
- 그림 -> `pixel` 단위 색상 표현 -> ( pixel * 24bit )
- 소리 -> 아날로그 신호 `샘플링`( 변화하는 신호 세기 일정 간격으로 측정 )하여 디지털화 
    - `나이키스트-섀넌 샘플링 이론` : 샘플링 비율 >= 가장 높은 주파수( 초당 사이클 개수 ) * 2
- 데이터 압축 -> `손실 압축`( 고주파 부분 삭제 ) / `무손실 압축`
    - `실행 길이 부호화` -> 행에서의 각 실행의 길이를 부호화 


---
<br>

# 03. 논리
