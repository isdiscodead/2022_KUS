# 01. 계산적 사고란 무엇인가

## I. 컴퓨터, 어디에나 있는 컴퓨터

### **computer** : 계산하는 사람 -> 기계식 -> 전자식 -> 양자식
- `전자식` -> 저항으로 조절해 전기 흐르면 1, 안 흐르면 0

### **Algorithm** : 컴퓨터를 이용해 풀 수 있는 문제의 해결 방법
-> 최초의 알고리즘( 논리적 흐름 )? 유클리드의 최대 공약수

프로그램 -> 장치에게 실행 방법을 명령, 프로그램마다 다른 결과 
응용 프로그램 / 시스템 SW ~/~ FirmWare( 기계어 ) ~/~ Hardware


<br>

## II. 최초의 소프트웨어 

    주판, 안티키테라 메커니즘 -> 파스칼린 -> 라이프니츠 계산기
1. `자카드 직기` -> 프로그램이 가능한 첫 번째 기계
2. `해석기관` -> 천공카드 방식의 기계식 계산기 이론 
    - 찰스 베비지 & 에이다 러브레이스 -> 최초의 컴퓨터 프로그래머

### 산업 혁명 
1. [1784] 증기 기관 + 기계화
2. [1870] 전기 + 대량 생산
~ 진공관 컴퓨터 
3. [1969] 컴퓨터 정보화 + 자동화
4. [2016] 인공지능

<br>

## III. 현대적 컴퓨터란? 
1. 전용 기계식 X -> 전자식( 전기로 동작 )
2. 아날로그 X -> 디지털( 비연속 )
3. 내장프로그램( SW ) 개념  
    - 입력 장치 / 출력 장치
    - 메모리 
    - 프로세서

<br>

## IV. 최초의 현대적 컴퓨터 
### `미분해석기` ( 전기 + 아날로그 회로 )
### **`ENIAC`** -> 디지털 + 전기 + 내장프로그램 ... 진공관 메모리
### `ABC 컴퓨터` -> 저장 / 범용 X, 최초의 완전 전자식
### `Z 시리즈` -> 최초의 범용 전자식, 내장 프로그램 X
### **`콜로서스`** -> 독일군 암호(이니그마) 해독, 경우의 수 자동화 
- `이미테이션 게임 ( turing test )` : 심판 vs 대상, 질문을 통해 인간인가, 기계인가 구분 불가능 -> 인공 지능
- `컴퓨터란?` 한가지가 아닌 여러 문제, 그냥 프로그램이 아닌 재프로그래밍 가능, 계산 뿐만 아니라 사람처럼 이후의 처리까지 생각하는 전자 두뇌 
- `기계가 생각을 할 수 있는가?` 사람처럼 할 순 X, 그러나 다르다고 생각하지 않는 것은 아님. 사람의 뇌가 다 다르듯이 기계도 서로 다르게 생각할 것. 

<br>

## V. 무어의 법칙
`Transister` -> 가변 저항 ( V=IR에서 저항을 조절해 0, 1 변경 )

`집적회로` -> 많은 양의 트랜지스터 단일 chip에 결합한 실리콘 웨어퍼
( 반도체 기술 ... bit, Tr, 선폭 속성 가짐 )

### Moore's Law 
인텔 창업자의 예견, 18개월 간격으로 집적회로 내 소자의 개수 *= 2 

-> 더 많은 소자들이 동일한 집적 회로 공간에? 전류가 흐르는 거리는 짧아지고 회로 속도는 상승 ! 

---
<br>

# 02. 실세계 정보는 어떻게 계산 가능한 데이터가 되는가?

## I. 정보와 데이터
|현실|컴퓨터세계|
|----|-----|
|정보( inform )|데이터( data )|
|연속적|이산적|
|아날로그 부호화|디지털 부호화|

*-> 이진수( bit)은 디지털 시스템의 최소 단위*

<br>

## II. 데이터 용량
- `byte` = 8bit, 256( 2^8 )개 패턴
- `word` : 하드웨어에 기반을 둔 데이터 용량 단위, CPU의 단일 항목 처리
    - bit수는 8의 배수로, 유형 별로 필요한 메모리 양이 다름 

<br> 

## III. 기수법
- `위치 기수법` : 밑( base ) / 기수 ( radix ) : 특정 기수법에 얼마나 많은 숫자가 존재하는지 명시하여 숫자 표현, 숫자의 위치는 밑의 거듭제곱과 연관됨
- `이진 기수법` : 밑을 2로 하는 위치 기수법, 각 숫자의 위치는 2의 멱승을 표시하고 값은 배수 ( 이진법 )

<br>

## IV. Bit 단위 숫자 표현
1. `sign-magnitude` 방식 int 표현
    - 맨 앞 비트를 부호 비트로 사용 (0 양수, 1 음수) -> -0과 +0이 생김
2. `2의 보수` 방식 int 표현
    - 1에 2의 보수 = -1 ( 부호 뒤집고 1 더하기 )

사용 비트 수의 한계, `정밀도` 제한 

-> `overflow`( 너무 큰 수 ) / `underflow`( 소수점 너무 작은 수 ) 오류 발생

<br>

## V. 다양한 데이터 표현
- 텍스트 -> `ASCII` 코드
- 색상 -> `RGB` ( 8bit * 3 chanel )
- 그림 -> `pixel` 단위 색상 표현 -> ( pixel * 24bit )
- 소리 -> 아날로그 신호 `샘플링`( 변화하는 신호 세기 일정 간격으로 측정 )하여 디지털화 
    - `나이키스트-섀넌 샘플링 이론` : 샘플링 비율 >= 가장 높은 주파수( 초당 사이클 개수 ) * 2
- 데이터 압축 -> `손실 압축`( 고주파 부분 삭제 ) / `무손실 압축`
    - `실행 길이 부호화` -> 행에서의 각 실행의 길이를 부호화 


---
<br>

# 03. 논리
## I. 논리란 무엇인가? 
1. `귀납적 논리` : n개의 관찰 경험 -> 결론 ( *필연적으로 불확실* )
2. `연역적 논리` : 참인 전제 -> 결론도 참 

### 삼단 논법 ( Syllogism )
두 개의 참인 전제 -> 결론 도출 
- 전제( premises ) : 참이라고 '가정'하는 명제
- 결론( Conclusion ) : 전제로부터 논리적으로 도출되는 참인 진술
- 기호 논리 : 기호, 논리 연산자를 사용한 논리 표현 

<br>

## II. 부울( Boolean ) 논리
컴퓨팅 시스템( DBMS의 SQL 등 )에서 사용되는 논리, True / False
- `명제( Proposition )` : 부울 논리의 기본 단위, 참 또는 거짓이 될 수 있는 Statement
-> 중간 혹은 동시에는 X ( 배중률 )
    - 기본 명제 : 부분들로 쪼갤 수 없는 명제, 약어( P, Q ... ) 사용
    - 합성 명제 : 기본 명제를 논리 연산자로 결합한 것 *ex) P and Q or R*
- `논리 값 (= 진리 값)` : 참( 1, true ) 또는 거짓( 0, false ) -> 2^n행의 `진리표`로 표현
- `arity` : 연산자에 대한 입력의 개수 = 피연산자 수

### 비교기 
-> P와 Q가 동치, 즉 동일한 진리표를 가질 때에만 true( 1 )

    (~(P or Q)) or ( P and Q )

<br>

### **명제 작성 규칙** 
1. 다음의 각각은 기본 명제이다.
    - 어떤 단일 문자 ( Q, P ... )
    - 참 값
    - 거짓 값
2. 다음의 각각 또한 명제이다. 
    - P and Q : `논리 곱`, 둘 다 참일 때 참
    - P or Q : `논리 합`, 둘 중 하나라도 참일 때 참
    - P -> Q : `imply`, P가 참일 때 Q가 거짓이면 거짓
    - P ≣ Q : `동치`, 진리표가 동일함
    - not P : `논리 부정`, T->F, F->T
    - ( P ) : `괄호`, 우선 순위 표현 
 
 ### **함축 ( Implication )** `P -> Q`
P: My car battery is dead.<br>
Q: My car won't start.<br>
-> P가 참인데 Q가 거짓일 때만 False !! 

- `역( Converse )` : ~p -> ~q ( True 보장 X )
- `항진( tautology )` : 항상 참
- `모순( contradiction )` : 항상 거짓 -> 무모순의 법칙( 거짓, 참 둘다는 X )
- `동치( equivalence )` : 동일한 진리표/값

<br>

### **요구 공학** -> SW 요구 문서
논리 명제 사용
- `분명성`
- `일관성`
- `완전성`<br>

`안전 중심 시스템` -> 올바로 동작 X시 심각한 문제... 수학적 기술, 정형 기법 사용 

---

<br>

# 04. 문제 해결
## I. 컴퓨팅 문제
컴퓨팅 문제란? 컴퓨터의 연산 능력을 활용해 해결 가능한 문제
- `최대 / 최소 값 찾기`
    - 동시에 최대, 최소 빠르게 구하기? 따로 구하는 것은 불러오는 시간 낭비 ...
    첫번째 원소를 최대/최소로 지정하고 크면 변경, 아니면 작은지 보고 변경하기
    - 교환 패턴은 CPU <-BUS-> Memory 이동 시간 때문에 코스트가 높음 
- `주어진 범위에서 소수( Prime Num )의 개수 찾기`
    - 합성수와 반대, 공인 인증서 등에서 사용됨
- `최단거리 예산` ( 2^n )
- `기상 예보` ( 예측 )

<br>

## II. 문제 해결의 4가지 전략 
### **① 문제 정의**
`요구사항( 상태-활동 테이블 )` ... 기능적 / 비기능적으로 기술 
- 열 -> 사용자들의 가능 액션
- 행 -> 프로그램의 가능 상태 
- 각 셀 -> 요구사항 번호 ( 생길 수 없는 상태는 회색, 요구사항이 없는 셀은 추가 작성 )
### **② 논리 추론**
- `원인-결과 관계` -> if-then
    - 순차화 : 선후 관계 명확하게
    - 패턴 : 교환, 반복 등 다양한 패턴 
- `연역적 추리` -> 이론을 통한 결론
- `귀납적 추론` -> 관찰을 통한 결론
### **③ 문제 분해** ( 분할 정복 ) 
... 일반적인 분해는 각기 다른 작은 문제, 알고리즘의 분할 정복 -> 크기가 작은 동일한 문제 
- `하향식 설계` : 실제 PL에서 많이 쓰임, 요약 후 구체화
- `연속 프로토타이핑` : 설계 단계 별로 프로토타이핑 -> 피드백 
- `멀티 태스킹` : 여러 작업 동시에
- `병렬 컴퓨팅` : 하나의 작업 나눠서 동시에
### **④ 추상화** : 제어, 자료
복잡한 문제 -> 사용 단순화
- `제어 추상화` : algorithm으로 표현 -> 순차, 선택, 반복, 제어의 추상화( 서브 알고리즘 참조 ), 병렬 처리 등...
- `자료 추상화` : class 다이어그램 + 매개변수 
- `행위 추상화` : use case 다이어그램 ( 사용자 -> 각 사용자가 가능한 작업 )

---

<br>

# 05. 알고리즘적 사고
## I. 알고리즘
### 알고리즘의 4대 요소
1. 모든 액션은 `의미( semantic )` 존재
2. 모든 액션들은 모호한 기술 X -> `구체적`으로 ...
3. 모든 액션들의 `순서`는 확실하게 정의
4. 알고리즘은 반드시 `유한한 숫자의 액션` 실행 후 종료 -> 무한 루프 X

<br>

## II. 소프트웨어와 프로그래밍 언어
### 컴퓨터 소프트웨어 -> 프로그래밍 언어로 작성된 단계들 수행 
### 프로그래밍 언어
- `명령형 언어` : 명령어 순차 실행
- `함수형 언어` : 입력값에 따른 출력값
- `선언형 언어` : 입력값에 팩트를 적용하여 출력값 생성

<br>

## III. 액션
-> 모든 **실행 가능한** 알고리즘은 가능한 액션들( 실행 가능 )의 `순서`로 표현
### **`네이밍 바인딩`** : 식별자 <-> 값 연결 
`identifier <- expression`
- 프로그래밍 요소들의 본질 구체적 반영, 필요 시 코멘트 추가
- `계산 상태` : 실행 중 어느 한 순간의 네임 바인딩의 집합, 실행에 따라 변경됨
### **`제어 흐름`** : 액션들의 실행 순서 
-> 유연하게 구성하여 다양한 입력에 반응 ! 
### **`루프`** : 반복
`while (   ) do {  } endwhile`
`for ( i=0 ; i<n ; i++ ) { }`
- `무한 루프` -> 논리 오류로 루프 종료 X 경우 
### **`선택`** 
`if (   ) then (    ) endif`
`if (   ) {    }`
1. 단방향 ( if )
2. 두방향 ( if - else )
3. 다방향 ( if - else if ... - else )
### **`모듈`** 
`module name() is {   } endmodule`
- `이해성` : 독립적으로 구성, 외부 지식 없이 이해 가능
- `캡슐화` : 모듈 내부의 데이터에만 영향
- `합성` : 내용 추가 없이 더 큰 모듈에 결합 가능
- 매개변수를 통한 `유연성`